# YandexPracticum-go-final-TODO
Финальный проект курса Go-разработчик с нуля на платформе ЯндексПрактикум.

## Описание

В итоговом задании нужно написать на Go веб-сервер, который реализует функциональность простейшего планировщика задач (аналог TODO-листа)
Это задание на проверку и закрепление навыков по написанию веб-сервера, работе с **REST API** и базами данных.

Планировщик должен хранить задачи, каждая из которых содержит дату дедлайна и заголовок с комментарием. Задачи могут повторяться по заданному правилу: например, ежегодно, через какое-то количество дней, в определённые дни месяца или недели. Если отметить такую задачу как выполненную, она переносится на следующую дату в соответствии с правилом. Обычные задачи при выполнении будут просто удаляться.

API будет следующие операции:
- добавить задачу;
- получить список задач;
- удалить задачу;
- получить параметры задачи;
- изменить параметры задачи;
- отметить задачу как выполненную.

## Проверка сервера и тесты

Работу сервера можно контролировать в браузере. Для этого имеется готовый фронтенд: **html**, **css**, **js-файлы**. Фронтенд отправляет на сервер **API-запросы**, необходимо реализовать их обработку по техническому заданию.
Кроме этого, для самостоятельной проверки работы есть доступ к тестам для проверки кода:
- Шаг 1 - `go test -run ^TestApp$ ./tests`
- Шаг 2 - `go test -run ^TestDB$ ./tests`
- Шаг 3 - `go test -run ^TestNextDate$ ./tests`
  Если реализована поддержка всех вариантов правил повторения, то нужно присвоить `true` переменной `FullNextDate` в файле `tests/settings.go`.
- Шаг 4 - `go test -run ^TestAddTask$ ./tests`
- Шаг 5 - `go test -run ^TestTasks$ ./tests`.
  Чтобы протестировать поиск, нужно присвоить переменной `Search` значение `true` в файле `tests/settings.go`
- Шаг 6.1 - `go test -run ^TestTask$ ./tests`
- Шаг 6.2 - `go test -run ^TestEditTask$ ./tests`
- Шаг 7.1 - `go test -run ^TestDone$ ./tests`
- Шаг 7.2 - `go test -run ^TestDelTask$ ./tests`
- All app `- go test -v ./tests`.
  Для веб-сервера с поддержкой аутентификации, нужно присвоить переменной `Token` в `tests/settings.go` значение токена, которое сервер возвратил из `/api/signin` и которое хранится в куке `token`.

## Запуск приложения
Для запуска приложения необходимо:
 - Ввести команду  `go build -o todo`
 - Запустить приложение командой `./todo`
 - Отркыть браузер и ввести в адресной строке браузера адрес: `http://localhost:7540/login.html`
 - Ввести пароль

## Техническое задание
Чтобы упорядочить работу, выполнение финального проекта разбито на шаги.

**В проекте имеются задания _со звездочкой_, выполнение которых необязательно, но желательно, такие задачи помечены ❄️**

#### Шаг 1. Запускаем веб-сервер
- ✅ Создать веб-сервер, который будет слушать определённый порт и возвращать запрашиваемые файлы фронтенда.
- ✅ ❄️ Реализовать возможность определять извне порт при запуске сервера. Если существует переменная окружения `TODO_PORT`, сервер при старте должен слушать порт со значением этой переменной.

#### Шаг 2. Проектируем и создаём БД
- ✅ Создать базу данных для хранения задач с использованием **SQLite**
- ✅ Реализовать при запуске сервера проверку, существует ли в директории приложения файл `scheduler.db`. Если его нет, следует создать базу данных с таблицей `scheduler`.
- ✅ Создать в таблицу `scheduler` с полями: **id**, **date**, **title**, **comment**, **repeat**
- ✅ ❄️ Реализовать возможность определять путь к файлу базы данных через переменную окружения `TODO_DBFILE`

#### Шаг 3. Правила повторения задач
- ✅  Написать функцию, которая будет вычислять следующую дату для задачи в соответствии с указанным правилом. Если правило не указано, отмеченная выполненной задача будет удаляться из таблицы.
    - ✅   `d <число>` - задача переносится на указанное число дней
    - ✅   `y` - задача выполняется ежегодно
    - ✅   ❄️`w <через запятую от 1 до 7>` - задача назначается в указанные дни недели, где 1 - понедельник, 7 - воскресенье.
    - ✅   ❄️`m <через запятую от 1 до 31,-1,-2> [через запятую от 1 до 12]` - задача назначается в указанные дни месяца. При этом вторая последовательность чисел опциональна и указывает на определённые месяцы.
- ✅ Добавить к серверу GET-обработчик `api/nextdate`.

#### Шаг 4. Добавляем задачу
- ✅ Добавить в веб-сервер POST-обработчик `/api/task`, который будет добавлять задачу в базу данных. Запрос и ответ должны передаваться в **JSON**-формате.

#### Шаг 5. Получаем список ближайших задач
- ✅ Реализовать обработчик для GET-запроса `/api/tasks`. Он должен возвращать список ближайших задач в формате **JSON** в виде списка в поле **tasks**. Задачи должны быть отсортированы по дате в сторону увеличения.
- ✅ ❄️Реализовать поиск задачи. Обработчик должен дополнительно обрабатывать параметр `search` в строке запроса.
- ✅ ❄️Добавить возможность выбрать задачи на конкретную дату.

#### Шаг 6. Редактирование задачи
- ✅ Добавить обработку GET-запроса, который возвратит все параметры задачи по её идентификатору.
- ✅ Добавить обработку PUT-запроса в хендлер для `/api/task` для сохранения измененных значений.

#### Шаг 7. Заканчиваем реализацию API
- ✅ Написать обработчик для POST-запроса `/api/task/done`, который делает задачу выполненной. Для периодической задачи нужно рассчитать и поменять дату следующего выполнения.
- ✅ Добавить в хендлер /api/task обработку запроса с методом DELETE - `/api/task/done?id=<идентификатор>`. В этом случае нужно удалить задачу с указанным идентификатором.

#### Аутентификация❄️
- ✅ Когда вводится пароль и нажимается кнопка `Войти`, фронтенд отправляет POST-запрос по адресу `/api/signin`. Нужно реализовать такой обработчик. Функция должна сверять указанный пароль с хранимым в переменной окружения `TODO_PASSWORD`. Если они совпадают, нужно сформировать **JWT-токен** и возвратить его в поле `token` **JSON**-объекта.
- ✅ Когда обработчик `/api/signin` будет реализован, необходимо добавить проверку аутентификации для следующих API-запросов:
  -  `/api/task` — все поддерживаемые HTTP методы
  -  `/api/tasks` — получение списка задач
  -  `/api/task/done` — запрос на выполнение задачи

#### Создание докер образа❄️
- ✅ Создать **докер-образ** и запустить контейнер с такими параметрами, чтобы планировщик работал в браузере и подключался к **SQLite** базе данных.

##### Для запуска приложения в контейнере:

`- docker compose build`

`- docker compose up` (с флагом `-d` для запуска в фоновом режиме)

По умолчанию выбран порт `7540`, если нужно изменить порт, то необходимо присвоить переменной `TODO_PORT` нужный порт.

Файл с базой данной по умолчанию хранится по пути `/db/scheduler.db`. Для изменения пути необходимо присвоить его переменной окружения `TODO_DBFILE`.

По умолчанию пароль для аутентификации `1234`, если нужно изменить, то необходимо присвоить переменной `TODO_PASSWORD` нужный пароль.

Для изменения значения переменных в файле `.env` нужно присвоить им соответствующие значения.
На локальной машине в ОС Linux нужно выполнить команды:

`- export TODO_PORT=7540`

`- export TODO_DBFILE=./db/scheduler.db`

`- export TODO_PASSWORD=1234`

